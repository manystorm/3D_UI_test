<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <title>WebXR 3D Calculator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
        }
        #vr-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border: 1px solid #fff;
            border-radius: 4px;
            background: rgba(0,0,0,0.5);
            color: white;
            font: 16px sans-serif;
            cursor: pointer;
            z-index: 999;
            display: none;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="info">
        Mouse: Click and drag to rotate camera<br>
        Touch: Tap to interact, drag to rotate<br>
        VR: Button will appear if VR is supported
    </div>
    <button id="vr-button">ENTER VR</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        // Essential Three.js variables
        let scene, camera, renderer;
        let raycaster, mouse;
        let controller1, controller2;
        let isVRSupported = false;
        let currentVRSession = null;

        // Interaction variables
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };
        let isTouching = false;

        // 3D Font
        let font = null;
        let fontLoaded = false;

        // UI Elements
        const interactiveObjects = [];
        let num1DisplayMesh, num2DisplayMesh, resultDisplayMesh;
        let num1Panel, num2Panel;

        // Calculator State
        let num1 = '0';
        let num2 = '0';
        let result = 'Result:';
        let activeInput = 'num1';

        // Colors
        const COLOR_BG = 0xf0f0f0;
        const COLOR_BUTTON = 0x4CAF50;
        const COLOR_BUTTON_HOVER = 0x3e8e41;
        const COLOR_RESULT_BG = 0xffffff;
        const COLOR_RESULT_TEXT = 0x000000;
        const COLOR_HEADER_TEXT = 0x000000;
        const COLOR_ACTIVE_INPUT = 0x66ff66;
        const COLOR_INACTIVE_INPUT = 0xdddddd;

        // --- INITIALIZATION ---

        async function init() {
            initThree();
            await loadFont();
            createUI();
            await setupVR(); // VR 설정을 안전하게 처리
            updateDisplays();
            
            // 일반 렌더링 루프 시작
            renderer.setAnimationLoop(animate);
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLOR_BG);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0.5, 1, 1);
            scene.add(directionalLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            addEventListeners();
        }

        function animate() {
            renderer.render(scene, camera);
        }

        // --- FONT & UI CREATION ---

        function loadFont() {
            const loader = new THREE.FontLoader();
            return new Promise((resolve) => {
                loader.load(
                    'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
                    (loadedFont) => {
                        font = loadedFont;
                        fontLoaded = true;
                        console.log('Font loaded successfully');
                        resolve(font);
                    },
                    undefined,
                    (error) => {
                        console.warn('Font could not be loaded, using fallback:', error);
                        fontLoaded = false;
                        resolve(null);
                    }
                );
            });
        }

        function createUI() {
            // Header
            const headerMesh = create3DText('Calculator', 0.2, { x: 0, y: 1.5, z: -3 }, COLOR_HEADER_TEXT);
            if (headerMesh) scene.add(headerMesh);

            // Input Fields
            const inputPanelGeo = new THREE.BoxGeometry(1.5, 0.5, 0.1);
            const inputPanelMat1 = new THREE.MeshStandardMaterial({ color: COLOR_INACTIVE_INPUT });
            const inputPanelMat2 = new THREE.MeshStandardMaterial({ color: COLOR_INACTIVE_INPUT });
            
            num1Panel = new THREE.Mesh(inputPanelGeo, inputPanelMat1);
            num1Panel.position.set(-1, 0.8, -3);
            scene.add(num1Panel);

            num2Panel = new THREE.Mesh(inputPanelGeo, inputPanelMat2);
            num2Panel.position.set(1, 0.8, -3);
            scene.add(num2Panel);

            // Operation Buttons
            const opButtons = [
                { text: '+', op: '+' },
                { text: '-', op: '-' },
                { text: 'x', op: '*' },
                { text: '/', op: '/' }
            ];
            opButtons.forEach((btn, i) => {
                const xPos = -1.125 + (i * 0.75);
                const button = createButton(btn.text, { x: xPos, y: 0.2, z: -3 }, { w: 0.5, h: 0.5, d: 0.2 }, COLOR_BUTTON, { type: 'operator', value: btn.op });
                scene.add(button);
                interactiveObjects.push(button);
            });

            // Result Display
            const resultPanelGeo = new THREE.BoxGeometry(3, 0.6, 0.1);
            const resultPanelMat = new THREE.MeshStandardMaterial({ color: COLOR_RESULT_BG });
            const resultPanel = new THREE.Mesh(resultPanelGeo, resultPanelMat);
            resultPanel.position.set(0, -0.5, -3);
            scene.add(resultPanel);

            // Number Pad
            const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '0', 'C'];
            for (let i = 0; i < numbers.length; i++) {
                const row = Math.floor(i / 3);
                const col = i % 3;
                const x = -0.75 + (col * 0.75);
                const y = -1.2 - (row * 0.5);
                const button = createButton(numbers[i], { x, y, z: -3 }, { w: 0.5, h: 0.4, d: 0.2 }, 0x555555, { type: 'input', value: numbers[i] });
                scene.add(button);
                interactiveObjects.push(button);
            }
        }

        function create3DText(text, size, position, color) {
            if (!font || !fontLoaded) {
                console.log('Font not loaded, creating fallback text');
                // 폰트가 없을 때 평면 텍스트 대신 간단한 지오메트리 사용
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = '#ffffff';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = '#000000';
                context.font = '20px Arial';
                context.textAlign = 'center';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const geometry = new THREE.PlaneGeometry(size * 4, size);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(position.x, position.y, position.z + 0.06);
                return mesh;
            }
            
            try {
                const textGeo = new THREE.TextGeometry(text.toString(), {
                    font: font,
                    size: size,
                    height: size * 0.1,
                    curveSegments: 4,
                });
                textGeo.computeBoundingBox();
                textGeo.translate(-textGeo.boundingBox.max.x * 0.5, -textGeo.boundingBox.max.y * 0.5, 0);
                const textMat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(textGeo, textMat);
                mesh.position.set(position.x, position.y, position.z + 0.06);
                return mesh;
            } catch (error) {
                console.error('Error creating 3D text:', error);
                return null;
            }
        }

        function createButton(text, position, size, color, userData) {
            const group = new THREE.Group();
            const buttonGeo = new THREE.BoxGeometry(size.w, size.h, size.d);
            const buttonMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
            const buttonMesh = new THREE.Mesh(buttonGeo, buttonMat);
            group.add(buttonMesh);

            const textMesh = create3DText(text, size.h * 0.5, { x: 0, y: 0, z: 0 }, 0xffffff);
            if (textMesh) {
                textMesh.position.z = size.d / 2 + 0.01;
                group.add(textMesh);
            }

            group.position.set(position.x, position.y, position.z);
            group.userData = userData;
            group.userData.buttonMesh = buttonMesh;
            group.userData.originalColor = color;
            return group;
        }

        // --- VR SETUP (안전하게 처리) ---

        async function setupVR() {
            const vrButton = document.getElementById('vr-button');
            
            // WebXR 지원 확인
            if (!navigator.xr) {
                console.log('WebXR not supported');
                return;
            }

            try {
                // VR 세션 지원 확인
                const supported = await navigator.xr.isSessionSupported('immersive-vr');
                if (supported) {
                    isVRSupported = true;
                    vrButton.style.display = 'block';
                    vrButton.addEventListener('click', onVRButtonClick);
                    console.log('VR is supported');
                    
                    // 컨트롤러 설정
                    setupControllers();
                } else {
                    console.log('VR not supported on this device');
                }
            } catch (error) {
                console.log('Error checking VR support:', error);
            }
        }

        function setupControllers() {
            // 컨트롤러 설정
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('select', onControllerSelect);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('select', onControllerSelect);
            scene.add(controller2);

            // 컨트롤러 레이 시각화
            const controllerLineMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            const controllerLineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -5)
            ]);
            const line1 = new THREE.Line(controllerLineGeo, controllerLineMat);
            const line2 = new THREE.Line(controllerLineGeo, controllerLineMat);
            controller1.add(line1);
            controller2.add(line2);
        }

        async function onVRButtonClick() {
            if (!isVRSupported) {
                alert('VR is not supported on this device');
                return;
            }

            const vrButton = document.getElementById('vr-button');
            
            try {
                if (renderer.xr.isPresenting) {
                    // VR 세션 종료
                    const session = renderer.xr.getSession();
                    if (session) {
                        await session.end();
                    }
                } else {
                    // VR 세션 시작
                    const session = await navigator.xr.requestSession('immersive-vr', {
                        optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
                    });
                    
                    currentVRSession = session;
                    
                    // 세션 이벤트 리스너
                    session.addEventListener('end', () => {
                        console.log('VR session ended');
                        currentVRSession = null;
                        vrButton.textContent = 'ENTER VR';
                    });
                    
                    // 세션 시작
                    renderer.xr.setSession(session);
                    vrButton.textContent = 'EXIT VR';
                    console.log('VR session started');
                }
            } catch (error) {
                console.error('VR session error:', error);
                alert('Failed to start VR session: ' + error.message);
            }
        }

        // --- STATE & DISPLAY MANAGEMENT ---

        function updateDisplays() {
            // 기존 텍스트 메시 제거
            if (num1DisplayMesh) scene.remove(num1DisplayMesh);
            if (num2DisplayMesh) scene.remove(num2DisplayMesh);
            if (resultDisplayMesh) scene.remove(resultDisplayMesh);

            // 입력 패널 색상 업데이트
            num1Panel.material.color.set(activeInput === 'num1' ? COLOR_ACTIVE_INPUT : COLOR_INACTIVE_INPUT);
            num2Panel.material.color.set(activeInput === 'num2' ? COLOR_ACTIVE_INPUT : COLOR_INACTIVE_INPUT);

            // 새 텍스트 메시 생성
            num1DisplayMesh = create3DText(num1, 0.2, num1Panel.position, COLOR_HEADER_TEXT);
            num2DisplayMesh = create3DText(num2, 0.2, num2Panel.position, COLOR_HEADER_TEXT);
            resultDisplayMesh = create3DText(result, 0.2, { x: 0, y: -0.5, z: -3 }, COLOR_RESULT_TEXT);

            if (num1DisplayMesh) scene.add(num1DisplayMesh);
            if (num2DisplayMesh) scene.add(num2DisplayMesh);
            if (resultDisplayMesh) scene.add(resultDisplayMesh);
        }

        function handleInput(value) {
            if (value === 'C') {
                if (activeInput === 'num1') num1 = '0';
                else num2 = '0';
            } else {
                let currentVal = activeInput === 'num1' ? num1 : num2;
                if (currentVal === '0' && value !== '.') {
                    currentVal = value;
                } else {
                    if (value === '.' && currentVal.includes('.')) return;
                    currentVal += value;
                }
                if (activeInput === 'num1') num1 = currentVal;
                else num2 = currentVal;
            }
            updateDisplays();
        }

        function calculate(operation) {
            const n1 = parseFloat(num1);
            const n2 = parseFloat(num2);

            if (isNaN(n1) || isNaN(n2)) {
                result = 'Result: Invalid numbers';
                updateDisplays();
                return;
            }

            let res;
            switch (operation) {
                case '+': res = n1 + n2; break;
                case '-': res = n1 - n2; break;
                case '*': res = n1 * n2; break;
                case '/':
                    if (n2 === 0) {
                        result = 'Result: Cannot divide by zero';
                        updateDisplays();
                        return;
                    }
                    res = n1 / n2;
                    break;
            }
            result = `Result: ${parseFloat(res.toPrecision(10))}`;
            updateDisplays();
        }

        // --- EVENT HANDLING ---

        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('click', onMouseClick);
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(event) { 
            isMouseDown = true; 
            setPreviousMousePos(event.clientX, event.clientY); 
        }
        
        function onMouseUp() { 
            isMouseDown = false; 
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            handleCameraRotation(event.clientX, event.clientY);
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                isTouching = true;
                setPreviousMousePos(event.touches[0].clientX, event.touches[0].clientY);
            }
        }
        
        function onTouchEnd(event) {
            if (event.changedTouches.length === 1) {
                handlePointerClick(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
            }
            isTouching = false;
        }
        
        function onTouchMove(event) {
            if (!isTouching || event.touches.length !== 1) return;
            event.preventDefault();
            handleCameraRotation(event.touches[0].clientX, event.touches[0].clientY);
        }

        function setPreviousMousePos(x, y) {
            previousMousePosition = { x, y };
        }

        function handleCameraRotation(clientX, clientY) {
            const deltaMove = {
                x: clientX - previousMousePosition.x,
                y: clientY - previousMousePosition.y
            };
            const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
                new THREE.Euler(
                    (deltaMove.y * 0.005),
                    (deltaMove.x * 0.005),
                    0,
                    'XYZ'
                )
            );
            camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
            setPreviousMousePos(clientX, clientY);
        }

        function onMouseClick(event) {
            handlePointerClick(event.clientX, event.clientY);
        }

        function handlePointerClick(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            checkIntersections();
        }

        function onControllerSelect(event) {
            const controller = event.target;
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(new THREE.Matrix4().extractRotation(controller.matrixWorld));
            checkIntersections();
        }

        function checkIntersections() {
            // 입력 패널 클릭 확인
            const panelIntersects = raycaster.intersectObjects([num1Panel, num2Panel]);
            if (panelIntersects.length > 0) {
                const clickedPanel = panelIntersects[0].object;
                activeInput = (clickedPanel === num1Panel) ? 'num1' : 'num2';
                updateDisplays();
                return;
            }

            // 버튼 클릭 확인
            const intersects = raycaster.intersectObjects(interactiveObjects, true);
            if (intersects.length > 0) {
                let parentGroup = intersects[0].object;
                while (parentGroup.parent && !parentGroup.userData.type) {
                    parentGroup = parentGroup.parent;
                }

                if (parentGroup.userData.type) {
                    animateButtonClick(parentGroup);
                    const { type, value } = parentGroup.userData;
                    if (type === 'input') {
                        handleInput(value);
                    } else if (type === 'operator') {
                        calculate(value);
                    }
                }
            }
        }

        function animateButtonClick(button) {
            const buttonMesh = button.userData.buttonMesh;
            if (!buttonMesh) return;

            const originalScale = button.scale.clone();
            const originalColor = new THREE.Color(button.userData.originalColor);
            const hoverColor = new THREE.Color(COLOR_BUTTON_HOVER);
            let progress = 0;
            const duration = 150;

            function anim() {
                progress += 16;
                const t = Math.min(progress / duration, 1);
                const scale = 1 - Math.sin(t * Math.PI) * 0.1;
                button.scale.set(scale, scale, scale);
                buttonMesh.material.color.lerpColors(hoverColor, originalColor, t);

                if (t < 1) {
                    requestAnimationFrame(anim);
                } else {
                    button.scale.copy(originalScale);
                    buttonMesh.material.color.copy(originalColor);
                }
            }
            anim();
        }

        // --- START THE APP ---
        init();
    </script>
</body>
</html>